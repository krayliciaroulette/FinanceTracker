@{
    ViewData["Title"] = "Expense Tracking";
    Layout = "_FinanceLayout";
}

<style>
    .tracking-header {
        text-align: center;
        margin: 2rem 0;
    }

    .tracking-title {
        font-size: 1.75rem;
        font-weight: 600;
        margin-bottom: 0.5rem;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
    }

    .tracking-subtitle {
        font-size: 1.1rem;
        color: var(--text-secondary);
        margin-bottom: 1.5rem;
    }

    .month-navigation {
        display: flex;
        justify-content: center;
        gap: 1rem;
        margin-bottom: 2rem;
    }

    .chart-card {
        background: var(--bg-card);
        border: 1px solid var(--border);
        border-radius: var(--radius-lg);
        padding: 1.5rem;
        box-shadow: var(--shadow-md);
        height: 550px;
    }

    .chart-title {
        text-align: center;
        font-size: 1.1rem;
        font-weight: 600;
        margin-bottom: 1.5rem;
        color: var(--text-primary);
    }

    .chart-container {
        position: relative;
        height: calc(100% - 3rem);
    }
</style>

<div class="fade-in-up">
    <!-- Header -->
    <div class="tracking-header">
        <h1 class="tracking-title">
            <span>📊</span>
            <span>Expense Tracking by Day</span>
        </h1>
        <h5 class="tracking-subtitle">Monthly Summary: @ViewBag.MonthName</h5>

        <!-- Month Navigation -->
        <div class="month-navigation">
            <a href="@Url.Action("ExpenseTracking", "Finance", new { year = ViewBag.Year, month = (int)ViewBag.Month - 1 })"
               class="btn btn-outline-light">
                ⬅ Previous Month
            </a>
            <a href="@Url.Action("ExpenseTracking", "Finance", new { year = ViewBag.Year, month = (int)ViewBag.Month + 1 })"
               class="btn btn-outline-light">
                Next Month ➡
            </a>
        </div>
    </div>

    <!-- Chart Card -->
    <div class="chart-card">
        <h5 class="chart-title">📊 Expense Breakdown</h5>
        <div class="chart-container">
            <canvas id="expenseChart"></canvas>
        </div>
    </div>
</div>

@section Scripts {
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        const groupedData = @Html.Raw(ViewBag.GroupedData ?? "[]");
        const categoryMainColors = @Html.Raw(ViewBag.CategoryColors ?? "{}");

        const ctx = document.getElementById('expenseChart').getContext('2d');

        // Build a map of subcategory -> main category (based on CategoryId)
        const subcategoryToMainCategory = {};
        const subcategoryToCategoryId = {};
        const categoryIdToName = {
            "1": "Food",
            "2": "Bills",
            "3": "Transportation",
            "4": "Others"
        };

        // First pass: map each subcategory to its main category and planned status
        groupedData.forEach(day => {
            day.Categories.forEach(cat => {
                const mainCat = categoryIdToName[cat.CategoryId] || "Others";
                subcategoryToMainCategory[cat.Category] = {
                    mainCategory: mainCat,
                    isPlanned: cat.IsPlanned,
                    categoryId: cat.CategoryId
                };
                subcategoryToCategoryId[cat.Category] = cat.CategoryId;
            });
        });

        // Get all unique subcategories
        const allSubcategories = [...new Set(groupedData.flatMap(d => d.Categories.map(c => c.Category)))];

        // Group by CategoryId and planned status
        const groupedByCategoryAndStatus = {};

        allSubcategories.forEach(subcat => {
            const info = subcategoryToMainCategory[subcat];
            const categoryId = info?.categoryId || "4";
            const isPlanned = info?.isPlanned || false;
            const key = `${categoryId}_${isPlanned ? 'planned' : 'unplanned'}`;

            if (!groupedByCategoryAndStatus[key]) {
                groupedByCategoryAndStatus[key] = [];
            }
            groupedByCategoryAndStatus[key].push(subcat);
        });

        // Sort groups: planned categories first, then unplanned
        const sortedGroups = Object.keys(groupedByCategoryAndStatus).sort((a, b) => {
            const aIsPlanned = a.endsWith('planned');
            const bIsPlanned = b.endsWith('planned');

            if (aIsPlanned && !bIsPlanned) return -1;
            if (!aIsPlanned && bIsPlanned) return 1;
            return 0;
        });

        // Flatten into sorted subcategories
        const sortedSubcategories = [];
        sortedGroups.forEach(groupKey => {
            sortedSubcategories.push(...groupedByCategoryAndStatus[groupKey]);
        });

        // Function to generate color variations
        function generateColorVariations(baseColor, count) {
            const colors = [baseColor];
            if (count <= 1) return colors;

            for (let i = 1; i < count; i++) {
                const factor = 1 + (i * 0.2);
                colors.push(adjustColor(baseColor, factor));
            }
            return colors;
        }

        function adjustColor(color, factor) {
            const r = Math.min(255, Math.floor(parseInt(color.slice(1, 3), 16) * factor));
            const g = Math.min(255, Math.floor(parseInt(color.slice(3, 5), 16) * factor));
            const b = Math.min(255, Math.floor(parseInt(color.slice(5, 7), 16) * factor));
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        // Assign colors based on main category and planned status
        const subcategoryColors = {};
        const categoryGroups = {}; // Groups planned subcategories by main category
        const unplannedColor = '#6b7280'; // Gray for unplanned

        sortedSubcategories.forEach(subcat => {
            const info = subcategoryToMainCategory[subcat];

            if (!info || !info.isPlanned) {
                // Unplanned = gray
                subcategoryColors[subcat] = unplannedColor;
            } else {
                // Planned = group by main category for color variations
                const mainCat = info.mainCategory;
                if (!categoryGroups[mainCat]) {
                    categoryGroups[mainCat] = [];
                }
                categoryGroups[mainCat].push(subcat);
            }
        });

        // Generate color variations for each main category group
        Object.entries(categoryGroups).forEach(([mainCat, subcats]) => {
            const baseColor = categoryMainColors[mainCat] || '#90a4ae';
            const colors = generateColorVariations(baseColor, subcats.length);

            subcats.forEach((subcat, idx) => {
                subcategoryColors[subcat] = colors[idx];
            });
        });

        // Create datasets - group by CategoryId for stacking
        const datasets = sortedSubcategories.map(subcat => {
            const info = subcategoryToMainCategory[subcat];
            const isPlanned = info && info.isPlanned;
            const categoryId = info?.categoryId || "4";
            const stackId = `category_${categoryId}_${isPlanned ? 'planned' : 'unplanned'}`;

            return {
                label: subcat + (isPlanned ? '' : ' (Unplanned)'),
                data: groupedData.map(d => {
                    const found = d.Categories.find(c => c.Category === subcat);
                    return found ? found.Total : 0;
                }),
                backgroundColor: subcategoryColors[subcat] || unplannedColor,
                borderWidth: 1,
                borderColor: '#1e293b',
                barPercentage: 0.95,
                categoryPercentage: 0.8,
                barThickness: 'flex',
                maxBarThickness: 60,
                stack: stackId
            };
        });

        new Chart(ctx, {
            type: "bar",
            data: {
                labels: groupedData.map(d => `Day ${d.Day}`),
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: "index",
                    intersect: false
                },
                scales: {
                    x: {
                        stacked: true,
                        ticks: {
                            color: "#94a3b8",
                            font: { size: 12, weight: '500' }
                        },
                        grid: {
                            color: "#334155",
                            drawBorder: false
                        }
                    },
                    y: {
                        stacked: true,
                        beginAtZero: true,
                        ticks: {
                            color: "#94a3b8",
                            font: { size: 12, weight: '500' },
                            callback: value => "₱" + value.toLocaleString()
                        },
                        grid: {
                            color: "#334155",
                            drawBorder: false
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'bottom',
                        labels: {
                            color: '#f1f5f9',
                            font: { size: 12, weight: '500' },
                            padding: 12,
                            boxWidth: 14,
                            boxHeight: 14,
                            usePointStyle: false
                        }
                    },
                    tooltip: {
                        backgroundColor: "rgba(15, 23, 42, 0.95)",
                        titleColor: "#f1f5f9",
                        bodyColor: "#f1f5f9",
                        titleFont: { weight: "bold", size: 14 },
                        bodyFont: { size: 13 },
                        padding: 12,
                        borderColor: "#334155",
                        borderWidth: 1,
                        displayColors: true,
                        callbacks: {
                            label: function(context) {
                                const dayData = groupedData[context.dataIndex];
                                const subcatName = context.dataset.label.replace(' (Unplanned)', '');
                                const catData = dayData.Categories.find(c => c.Category === subcatName);

                                if (catData) {
                                    const plannedTag = catData.IsPlanned ? '' : ' (Unplanned)';
                                    let label = `${catData.Category}${plannedTag}: ₱${catData.Total.toLocaleString()}`;

                                    if (catData.Description) {
                                        label += ` – ${catData.Description}`;
                                    }

                                    return label;
                                }
                                return '';
                            }
                        }
                    }
                }
            }
        });
    </script>
}